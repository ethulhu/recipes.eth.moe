<html>
<head>
  <meta charset='utf-8'>
  <title>recipes</title>
  <meta name='viewport'
        content='width=device-width, initial-scale=1.0'>
  <link rel='icon' href='./icon.png'>
   <!-- Add to home screen for Safari on iOS -->
  <meta name='apple-mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-status-bar-style' content='black'>
  <meta name='apple-mobile-web-app-title' content='Recipes'>
  <link rel='apple-touch-icon' href='./icon.png'>
  <style>
    body {
      font-family: sans-serif;
      font-size: 14pt;
    }

    a {
      color: #AAA;
      transition-duration: 0.1s;
      transition-timing-function: ease-in-out;
    }
    a.visited {
      color: #AAA;
    }
    a:hover {
      color: #99F;
    }

    ul.doable {
      list-style: none;
      padding: 0;
    }
    ul.doable span {
      padding-left: 0.5ch;  // Moves it away from the bullet.
    }
    label:not(.done):hover {
      text-decoration: line-through;
      color: #BBB;
    }
    label.done {
      text-decoration: line-through;
      color: #BBB;
    }
  </style>
</head>

<body>
  <main>
  </main>

<script type='module'>
'use strict';

import { Elems } from './elems.mjs';
import { Menu } from './menu.mjs';
import { Recipe } from './recipe.mjs';

// Setup.

Elems.register( {
    toObject: window,
    withNameFunc: n => '_' + n,
  },
  'nav', 'a', 'h1', 'li', 'h2', 'section', 'label', 'input', 'ul', 'span');

function handleEvent( querySelector, event, handlerFunc ) {
  window.addEventListener( event, e => {
    if ( e.target.matches( querySelector ) ) {
      handlerFunc( e );
    }
  } );
}

// Page render-funcs.

function renderMenu( text ) {
  const menu = Menu.parse( text );

  document.title = 'recipes';

  const render = Elems.renderFuncForSelector( 'main' );
  render(
    _h1( 'recipes' ),
    _nav(
      _ul(
        menu.items.map(
          item => _li(
                    _a(
                      item.name,
                      { href: '#' + item.path },
                    )
                  )
        )
      )
    )
  );
}

Storage.prototype.putObject =
  ( k, v ) => localStorage.setItem( k, JSON.stringify( v ) );

Storage.prototype.getObject =
  k => JSON.parse( localStorage.getItem( k ) || 'null' );

// object = {
//   lastRead: epochTime,
//   needs: { string, bool },
//   steps: { string, bool },
// }
function modifyState( recipeName, modifyFunc ) {
  const path = 'recipes:' + recipeName;
  let state = localStorage.getObject( path ) ||
              { lastRead: Date.now(), needs: {}, steps: {} };
  modifyFunc( state );
  state.lastRead = Date.now();
  localStorage.putObject( path, state );
  return state;
}
function setDoable( recipe, section, doable, done ) {
  modifyState( recipe, state => {
    state[ section ][ doable ] = done;
  } );
}

function renderRecipe( text ) {
  const recipe = Recipe.parse( text );
  const state = modifyState( recipe.name, s => s );

  document.title = 'recipes - ' + recipe.name;

  const render = Elems.renderFuncForSelector( 'main' );

  const newDoableSection =
    ( title, items ) =>
      _section(
        _h2( title ),
        _ul(
          { class: 'doable' },
          items.map( text =>
            _li(
              _label(
                { class:
                    state[ title ][ text ] ?  'done' : '' },
                _input(
                  { type: 'checkbox' },
                  { class: 'doable' },
                  { checked:
                      state[ title ][ text ] ? true : null },
                  { recipe: recipe.name },
                  { section: title },
                  { doable: text },
                ),
                _span( text ),
              )
            )
          ),
        ),
      );

  render(
    _a(
      'home',
      { href: '#' },
    ),
    ' ',
    _a(
      'reset',
      { id: 'reset' },
      { href: window.location.hash },
      { recipe: recipe.name },
    ),
    _h1( recipe.name ),
    ['needs', 'steps'].map( key =>
      newDoableSection( key, recipe[ key ] )
    ),
  );
}
handleEvent( 'input.doable', 'change', e => {
  e.target.parentElement.classList.toggle( 'done' );

  setDoable(
    e.target.getAttribute( 'recipe' ),
    e.target.getAttribute( 'section' ),
    e.target.getAttribute( 'doable' ),
    e.target.parentElement.classList.contains( 'done' )
  );
} );
handleEvent( '#reset', 'click', e => {
  modifyState( e.target.getAttribute( 'recipe' ), s => {
    s.steps = {};
    s.needs = {};
  } );
} );

// Loaders.

function load( path, renderFunc ) {
  fetch( path ).then( response => {
    if ( response.status !== 200 ) {
      console.log( 'failed to fetch ' + path );
      return;
    }

    response.text().then( renderFunc );
  } );
}

function renderPage() {
  if ( ! window.location.hash ) {
    load( './recipes.list', renderMenu );
  } else {
    const name = window.location.hash.slice( 1 );
    load( './recipes/' + name, renderRecipe );
  }
}
window.addEventListener( 'popstate', renderPage ); // Refresh on history or URL change.
renderPage();

</script>
</body>
</html>
