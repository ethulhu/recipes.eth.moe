<html>
<head>
  <meta charset='utf-8'>
  <title>recipes</title>
  <meta name='viewport'
        content='width=device-width, initial-scale=1.0'>
  <link rel='icon' href='./icon.png'>
   <!-- Add to home screen for Safari on iOS -->
  <meta name='apple-mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-status-bar-style' content='black'>
  <meta name='apple-mobile-web-app-title' content='Recipes'>
  <link rel='apple-touch-icon' href='./icon.png'>
  <style>
    body {
      font-family: sans-serif;
      font-size: 14pt;
    }

    a {
      color: #AAA;
      transition-duration: 0.1s;
      transition-timing-function: ease-in-out;
    }
    a.visited {
      color: #AAA;
    }
    a:hover {
      color: #99F;
    }

    ul.doable {
      list-style: none;
      padding: 0;
    }
    ul.doable span {
      padding-left: 0.5ch;  // Moves it away from the bullet.
    }
    label.done {
      text-decoration: line-through;
      color: #BBB;
    }
  </style>
</head>

<body>
  <main>
  </main>

<script type='module'>
'use strict';

import { Elems  } from './elems.mjs';
import { Menu   } from './menu.mjs';
import { Recipe } from './recipe.mjs';
import { Search } from './search.mjs';

// Setup.

[
  'a',
  'h1',
  'h2',
  'input',
  'label',
  'li',
  'nav',
  'section',
  'span',
  'ul'
].forEach( tag => window[ '_' + tag ] = Elems.elem( tag ) );

function handleEvent( querySelector, event, handlerFunc ) {
  window.addEventListener( event, e => {
    if ( e.target.matches( querySelector ) ) {
      handlerFunc( e );
    }
  } );
}

// Page render-funcs.

// renderRecipeList is constructed inside renderMenu.
let renderRecipeList = query => {};

function renderMenu( text ) {
  const menu = Menu.parse( text );

  document.title = 'recipes';

  const render = Elems.renderFuncForSelector( 'main' );
  render(
    _h1( 'recipes' ),
    _input(
      { id: 'search' },
      { style: 'visibility: hidden; display: none;' },
      { autocomplete: 'off' },
    ),
    _nav(
      _ul(
        { id: 'recipeList' },
      )
    )
  );

  renderRecipeList = query => {
    const render = Elems.renderFuncForSelector( '#recipeList' );
    const match = Search.matchOneOfFuncForQuery( query );
    render( menu.items.filter( item => match(
                                         item.tags
                                             .concat( item.name ) ) )
                      .map( item => _li(
                                      { class: 'recipe' },
                                      _a(
                                        item.name,
                                        { href: '#' + item.path },
                                      )
                                    ) ) );
  };

  renderRecipeList( '' );
}
document.onkeydown = e => {
  if ( e.key === 'Escape' ) { e.preventDefault(); }
};
handleEvent( 'body', 'keydown', e => {
  if ( e.key === '/' ) {
    e.preventDefault();
    const search = _input( { id: 'search', autocomplete: 'off' } );
    const nav = document.querySelector( 'nav' )
    nav.insertBefore( search, nav.firstChild );
    search.focus();
  }
} );
handleEvent( '#search', 'keyup', e => {
  let query = e.target.value;
  if ( e.key === 'Escape' ) {
    e.preventDefault();
    const search = document.querySelector( '#search' )
    search.parentElement.removeChild( search );
    query = '';
  }
  renderRecipeList( query );
} );

Storage.prototype.putObject =
  ( k, v ) => localStorage.setItem( k, JSON.stringify( v ) );

Storage.prototype.getObject =
  k => JSON.parse( localStorage.getItem( k ) || 'null' );

// object = {
//   lastRead: epochTime,
//   needs: { string, bool },
//   steps: { string, bool },
// }
function modifyState( recipeName, modifyFunc ) {
  const path = 'recipes:' + recipeName;
  let state = localStorage.getObject( path ) ||
              { lastRead: Date.now(), needs: {}, steps: {} };
  modifyFunc( state );
  state.lastRead = Date.now();
  localStorage.putObject( path, state );
  return state;
}
function setDoable( recipe, section, doable, done ) {
  modifyState( recipe, state => {
    state[ section ][ doable ] = done;
  } );
}

function renderRecipe( text ) {
  const recipe = Recipe.parse( text );
  const state = modifyState( recipe.name, state => {
    const DAY = 1000 * 60 * 60 * 24;
    if ( ( Date.now() - new Date(state.lastRead) ) > ( 7 * DAY ) ) {
      state.needs = {};
      state.steps = {};
    }
  } );

  document.title = 'recipes - ' + recipe.name;

  const render = Elems.renderFuncForSelector( 'main' );

  const newDoableSection =
    ( title, items ) =>
      _section(
        _h2( title ),
        _ul(
          { class: 'doable' },
          items.map( text =>
            _li(
              _label(
                { class:
                    state[ title ][ text ] ?  'done' : '' },
                _input(
                  { type: 'checkbox' },
                  { class: 'doable' },
                  { checked:
                      state[ title ][ text ] ? true : null },
                  { recipe: recipe.name },
                  { section: title },
                  { doable: text },
                ),
                _span( text ),
              )
            )
          ),
        ),
      );

  render(
    _a(
      'home',
      { href: '#' },
    ),
    ' ',
    _a(
      'reset',
      { id: 'reset' },
      { href: window.location.hash },
      { recipe: recipe.name },
    ),
    _h1( recipe.name ),
    ['needs', 'steps'].map( key =>
      newDoableSection( key, recipe[ key ] )
    ),
  );
}
handleEvent( 'input.doable', 'change', e => {
  e.target.parentElement.classList.toggle( 'done' );

  setDoable(
    e.target.getAttribute( 'recipe' ),
    e.target.getAttribute( 'section' ),
    e.target.getAttribute( 'doable' ),
    e.target.parentElement.classList.contains( 'done' )
  );
} );
handleEvent( '#reset', 'click', e => {
  modifyState( e.target.getAttribute( 'recipe' ), s => {
    s.steps = {};
    s.needs = {};
  } );
} );

// Loaders.

function load( path, renderFunc ) {
  fetch( path ).then( response => {
    if ( response.status !== 200 ) {
      console.log( 'failed to fetch ' + path );
      return;
    }

    response.text().then( renderFunc );
  } );
}

function renderPage() {
  if ( ! window.location.hash ) {
    load( './recipes.json', renderMenu );
  } else {
    const name = window.location.hash.slice( 1 );
    load( './recipes/' + name, renderRecipe );
  }
}
window.addEventListener( 'popstate', renderPage ); // Refresh on history or URL change.
renderPage();

</script>
</body>
</html>
